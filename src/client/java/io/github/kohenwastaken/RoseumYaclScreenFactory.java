package io.github.kohenwastaken;

import dev.isxander.yacl3.api.*;
import dev.isxander.yacl3.api.controller.BooleanControllerBuilder;
import dev.isxander.yacl3.api.controller.EnumControllerBuilder;
import dev.isxander.yacl3.api.controller.IntegerSliderControllerBuilder;
import net.fabricmc.api.EnvType;
import net.fabricmc.api.Environment;
import net.minecraft.client.MinecraftClient;
import net.minecraft.client.gui.screen.Screen;
import net.minecraft.text.Text;

@Environment(EnvType.CLIENT)
public final class RoseumYaclScreenFactory {

    private RoseumYaclScreenFactory() {}

    public static Screen create(Screen parent) {
        final var cfg = RoseumConfig.INSTANCE;

        // ===== CRAFTING – ALLOY =====
        Option<Boolean> craftingAlloyEnabled = Option.<Boolean>createBuilder()
                .name(Text.literal("Crafting Alloy: Enabled"))
                .description(OptionDescription.of(Text.literal("Enable or disable Rose Gold alloy crafting recipes generated by the mod.")))
                .binding(cfg.enableCraftingAlloy, () -> cfg.enableCraftingAlloy, v -> cfg.enableCraftingAlloy = v)
                .controller(BooleanControllerBuilder::create)
                .build();

        Option<RoseumConfig.Mode> modeOpt = Option.<RoseumConfig.Mode>createBuilder()
                .name(Text.literal("Alloy Mode"))
                .description(OptionDescription.of(Text.literal("How many copper + gold are required (total 4) for ALLOY CRAFTING recipes.")))
                .binding(cfg.mode, () -> cfg.mode, v -> cfg.mode = v)
                .controller(opt -> EnumControllerBuilder.create(opt)
                        .enumClass(RoseumConfig.Mode.class)
                        .formatValue(m -> switch (m) {
                            case C3_G1 -> Text.literal("3 Copper + 1 Gold");
                            case C2_G2 -> Text.literal("2 Copper + 2 Gold");
                            case C1_G3 -> Text.literal("1 Copper + 3 Gold");
                        }))
                .available(cfg.enableCraftingAlloy)
                .build();

        Option<RoseumConfig.InputKind> inputOpt = Option.<RoseumConfig.InputKind>createBuilder()
                .name(Text.literal("Allowed Inputs"))
                .description(OptionDescription.of(Text.literal("Which item forms are accepted by ALLOY CRAFTING recipes.")))
                .binding(cfg.inputKind, () -> cfg.inputKind, v -> cfg.inputKind = v)
                .controller(opt -> EnumControllerBuilder.create(opt)
                        .enumClass(RoseumConfig.InputKind.class)
                        .formatValue(k -> switch (k) {
                            case INGOT -> Text.literal("Ingots Only");
                            case RAW   -> Text.literal("Raw Ores Only");
                            case BOTH  -> Text.literal("Both (mix allowed)");
                        }))
                .available(cfg.enableCraftingAlloy)
                .build();

        Option<Integer> countOpt = Option.<Integer>createBuilder()
                .name(Text.literal("Output Count"))
                .description(OptionDescription.of(Text.literal("How many alloy items the ALLOY CRAFTING recipe outputs.")))
                .binding(cfg.outputCount, () -> cfg.outputCount, v -> cfg.outputCount = v)
                .controller(opt -> IntegerSliderControllerBuilder.create(opt)
                        .range(1, 4)
                        .step(1)
                        .formatValue(i -> Text.literal(Integer.toString(i))))
                .available(cfg.enableCraftingAlloy)
                .build();

        OptionGroup craftingGroup = OptionGroup.createBuilder()
                .name(Text.literal("Crafting – Alloy"))
                .option(craftingAlloyEnabled)
                .option(modeOpt)
                .option(inputOpt)
                .option(countOpt)
                .build();

        ConfigCategory craftingCat = ConfigCategory.createBuilder()
                .name(Text.literal("Crafting"))
                .group(craftingGroup)
                .build();

        // ===== SMITHING – ALLOY =====
        Option<Boolean> smithAlloyEnabled = Option.<Boolean>createBuilder()
                .name(Text.literal("Smithing Alloy: Enabled"))
                .description(OptionDescription.of(Text.literal("Enable or disable the smithing alloy recipe (1 Copper + 1 Gold → 1 Rose Gold Ingot).")))
                .binding(cfg.enableSmithingAlloy, () -> cfg.enableSmithingAlloy, v -> cfg.enableSmithingAlloy = v)
                .controller(BooleanControllerBuilder::create)
                .build();

        Option<RoseumConfig.TemplatePolicy> smithAlloyPolicy = Option.<RoseumConfig.TemplatePolicy>createBuilder()
                .name(Text.literal("Smithing Alloy: Template Policy"))
                .description(OptionDescription.of(Text.literal(
                        "What happens to the template after smithing:\n" +
                        "• OFF — No template required; if present, it will be returned.\n" +
                        "• DO_NOT_CONSUME — Template is required if recipe wants it, but never consumed (returned).\n" +
                        "• CONSUME — Vanilla behavior (consumed).\n" +
                        "• DAMAGE — If damageable, takes 1 damage; otherwise returned."
                )))
                .binding(cfg.smithingAlloy_templatePolicy,
                        () -> cfg.smithingAlloy_templatePolicy,
                        v  -> cfg.smithingAlloy_templatePolicy = v)
                .controller(opt -> EnumControllerBuilder.create(opt)
                        .enumClass(RoseumConfig.TemplatePolicy.class)
                        .formatValue(p -> switch (p) {
                            case OFF -> Text.literal("OFF (no template required; return if present)");
                            case DO_NOT_CONSUME -> Text.literal("Return (not consumed)");
                            case DAMAGE -> Text.literal("Damage on use");
                            default -> Text.literal("Consume (vanilla)");
                        }))
                .available(cfg.enableSmithingAlloy)
                .build();

        OptionGroup smithAlloyGroup = OptionGroup.createBuilder()
                .name(Text.literal("Smithing – Alloy (1 Copper + 1 Gold → 1 Rose Gold Ingot)"))
                .option(smithAlloyEnabled)
                .option(smithAlloyPolicy)
                .build();

        // ===== SMITHING – TRANSFORM =====
        Option<Boolean> smithTransEnabled = Option.<Boolean>createBuilder()
                .name(Text.literal("Smithing Transform: Enabled"))
                .description(OptionDescription.of(Text.literal("Enable or disable armor transform (e.g., Gold Armor + Copper → Rose Gold Armor).")))
                .binding(cfg.enableSmithingTransform, () -> cfg.enableSmithingTransform, v -> cfg.enableSmithingTransform = v)
                .controller(BooleanControllerBuilder::create)
                .build();

        Option<RoseumConfig.TemplatePolicy> smithTransPolicy = Option.<RoseumConfig.TemplatePolicy>createBuilder()
                .name(Text.literal("Smithing Transform: Template Policy"))
                .description(OptionDescription.of(Text.literal(
                        "What happens to the template after transforming:\n" +
                        "• OFF — No template required; if present, it will be returned.\n" +
                        "• DO_NOT_CONSUME — Template is required if recipe wants it, but never consumed (returned).\n" +
                        "• CONSUME — Vanilla behavior (consumed).\n" +
                        "• DAMAGE — If damageable, takes 1 damage; otherwise returned."
                )))
                .binding(cfg.smithingTransform_templatePolicy,
                        () -> cfg.smithingTransform_templatePolicy,
                        v  -> cfg.smithingTransform_templatePolicy = v)
                .controller(opt -> EnumControllerBuilder.create(opt)
                        .enumClass(RoseumConfig.TemplatePolicy.class)
                        .formatValue(p -> switch (p) {
                            case OFF -> Text.literal("OFF (no template required; return if present)");
                            case DO_NOT_CONSUME -> Text.literal("Return (not consumed)");
                            case DAMAGE -> Text.literal("Damage on use");
                            default -> Text.literal("Consume (vanilla)");
                        }))
                .available(cfg.enableSmithingTransform)
                .build();

        OptionGroup smithTransformGroup = OptionGroup.createBuilder()
                .name(Text.literal("Smithing – Transform (Gold Armor + Copper → Rose Gold Armor)"))
                .option(smithTransEnabled)
                .option(smithTransPolicy)
                .build();

        ConfigCategory smithingCat = ConfigCategory.createBuilder()
                .name(Text.literal("Smithing"))
                .group(smithAlloyGroup)
                .group(smithTransformGroup)
                .build();

        // ===== Save callback =====
        Runnable saver = () -> {
            cfg.outputCount = Math.max(1, Math.min(4, cfg.outputCount));
            RoseumConfig.savePretty();

            var mc = MinecraftClient.getInstance();
            if (mc.player != null) {
                mc.player.sendMessage(
                        Text.literal("[Roseum] Config saved. Use /reload (or re-enter world) to apply recipe changes."),
                        false
                );
            }
        };

        return YetAnotherConfigLib.createBuilder()
                .title(Text.literal("Roseum Config"))
                .category(craftingCat)
                .category(smithingCat)
                .save(saver)
                .build()
                .generateScreen(parent);
    }
}
